<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Moments ‚Äî Star Program</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-slate-100">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    const uid = () => Math.random().toString(36).slice(2,9);

    // ---- Storage Keys ----
    const USERS_KEY = "moments_users";
    const SESSION_KEY = "moments_session";
    const TIMELINES_KEY = "moments_timelines";
    const MESSAGES_KEY = "moments_messages";

    function read(key){ try{return JSON.parse(localStorage.getItem(key))||{}}catch{return{}} }
    function write(key,val){ localStorage.setItem(key,JSON.stringify(val)); }

    // ---- Users ----
    function ensureUserShape(u){
      if(!u.friends) u.friends=[];
      if(!u.pendingRequests) u.pendingRequests=[];
      if(typeof u.isStar==='undefined') u.isStar=false;
      return u;
    }
    function createAccount(username,password,isStar=false){
      const users=read(USERS_KEY);
      if(users[username]) throw new Error("username taken");
      users[username]=ensureUserShape({username,password,id:uid(),friends:[],pendingRequests:[],isStar});
      write(USERS_KEY,users);
    }
    function signIn(username,password){
      const users=read(USERS_KEY);
      if(!users[username]) throw new Error("no such user");
      if(users[username].password!==password) throw new Error("wrong password");
      write(SESSION_KEY,{username});
      return users[username];
    }
    function signOut(){ localStorage.removeItem(SESSION_KEY); }
    function currentSession(){ return read(SESSION_KEY); }

    // ---- Friend Requests ----
    function sendFriendRequest(from, to){
      const users = read(USERS_KEY);
      if(!users[to]) throw new Error("no such user");
      users[to] = ensureUserShape(users[to]);
      if(!users[to].pendingRequests.includes(from) && !users[to].friends.includes(from)){
        users[to].pendingRequests.push(from);
        write(USERS_KEY,users);
      }
    }
    function acceptFriendRequest(acceptor, fromUser){
      const users = read(USERS_KEY);
      if(!users[acceptor] || !users[fromUser]) return;
      users[acceptor] = ensureUserShape(users[acceptor]);
      users[fromUser] = ensureUserShape(users[fromUser]);
      users[acceptor].pendingRequests = (users[acceptor].pendingRequests||[]).filter(u=>u!==fromUser);
      if(!users[acceptor].friends.includes(fromUser)) users[acceptor].friends.push(fromUser);
      if(!users[fromUser].friends.includes(acceptor)) users[fromUser].friends.push(acceptor);
      write(USERS_KEY,users);
    }
    function declineFriendRequest(decliner, fromUser){
      const users = read(USERS_KEY);
      if(!users[decliner]) return;
      users[decliner] = ensureUserShape(users[decliner]);
      users[decliner].pendingRequests = (users[decliner].pendingRequests||[]).filter(u=>u!==fromUser);
      write(USERS_KEY,users);
    }
    function getFriends(user){ const users=read(USERS_KEY); return users[user]?.friends||[]; }
    function getPendingRequests(user){ const users=read(USERS_KEY); return users[user]?.pendingRequests||[]; }

    // ---- App ----
    function MomentsApp(){
      const [user,setUser]=useState(null);
      const [view,setView]=useState("timelines");
      const [timelines,setTimelines]=useState(read(TIMELINES_KEY));
      const [messages,setMessages]=useState(read(MESSAGES_KEY));
      const channelRef=useRef(null);

      useEffect(()=>{
        const session=currentSession();
        if(session?.username){
          const users=read(USERS_KEY);
          if(users[session.username]) setUser(users[session.username]);
        }
      },[]);

      useEffect(()=>{
        channelRef.current=new BroadcastChannel("moments_channel");
        channelRef.current.onmessage=(e)=>{
          if(e.data.type==="message"){
            setMessages(prev=>{
              const m={...prev};
              if(!m[e.data.to]) m[e.data.to]={};
              if(!m[e.data.to][e.data.from]) m[e.data.to][e.data.from]=[];
              m[e.data.to][e.data.from].push(e.data.msg);
              write(MESSAGES_KEY,m);
              return m;
            });
          }
          if(e.data.type==="timelines_update"){
            setTimelines(read(TIMELINES_KEY));
          }
          if(e.data.type==="users_update"){
            const session=currentSession();
            if(session?.username){
              const users=read(USERS_KEY);
              if(users[session.username]) setUser(users[session.username]);
            }
          }
        };
        return ()=>channelRef.current.close();
      },[]);

      function saveTimelines(updated){
        setTimelines(updated); write(TIMELINES_KEY,updated);
        if(channelRef.current) channelRef.current.postMessage({type:"timelines_update"});
      }

      function handleCreateTimeline(name,iconFile){
        const reader=new FileReader();
        reader.onload=()=>{
          const newT={id:uid(),name,owner:user.username,posts:[],locked:false,icon:reader.result};
          const updated={...timelines,[newT.id]:newT};
          saveTimelines(updated);
        };
        if(iconFile) reader.readAsDataURL(iconFile);
        else{
          const newT={id:uid(),name,owner:user.username,posts:[],locked:false,icon:null};
          const updated={...timelines,[newT.id]:newT};
          saveTimelines(updated);
        }
      }

      function handleAddPost(tid,content,type){
        const t={...timelines[tid]};
        t.posts.push({id:uid(),owner:user.username,type,content,created:Date.now()});
        const updated={...timelines,[tid]:t};
        saveTimelines(updated);
      }

      function handleDeletePost(tid,pid){
        const t={...timelines[tid], posts: timelines[tid].posts.filter(p=>p.id!==pid)};
        const updated={...timelines,[tid]:t};
        saveTimelines(updated);
      }

      function toggleLock(tid){
        const t={...timelines[tid]};
        t.locked=!t.locked;
        const updated={...timelines,[tid]:t};
        saveTimelines(updated);
      }

      function requestAddFamily(targetUsername){
        try{
          sendFriendRequest(user.username,targetUsername);
          if(channelRef.current) channelRef.current.postMessage({type:"users_update"});
          alert("Friend request sent.");
        }catch(e){ alert(e.message); }
      }
      function acceptRequest(fromUser){
        acceptFriendRequest(user.username,fromUser);
        if(channelRef.current) channelRef.current.postMessage({type:"users_update"});
        setUser(read(USERS_KEY)[user.username]);
      }
      function declineRequest(fromUser){
        declineFriendRequest(user.username,fromUser);
        if(channelRef.current) channelRef.current.postMessage({type:"users_update"});
        setUser(read(USERS_KEY)[user.username]);
      }

      function sendMessage(to,text){
        const msg={from:user.username,text,created:Date.now()};
        setMessages(prev=>{
          const m={...prev};
          if(!m[user.username]) m[user.username]={};
          if(!m[user.username][to]) m[user.username][to]=[];
          m[user.username][to].push(msg);
          write(MESSAGES_KEY,m);
          return m;
        });
        if(channelRef.current) channelRef.current.postMessage({type:"message",to,from:user.username,msg});
      }

      return user
        ? <Dashboard user={user} setUser={setUser} view={view} setView={setView}
            timelines={timelines} handleCreateTimeline={handleCreateTimeline}
            handleAddPost={handleAddPost} handleDeletePost={handleDeletePost}
            toggleLock={toggleLock} requestAddFamily={requestAddFamily}
            acceptRequest={acceptRequest} declineRequest={declineRequest}
            messages={messages} sendMessage={sendMessage}/>
        : <AuthPanel setUser={setUser} />;
    }

    // ---- Auth Panel ----
    function AuthPanel({setUser}){
      const [mode,setMode]=useState("signin");
      const [u,setU]=useState(""),[p,setP]=useState(""),[err,setErr]=useState("");
      function submit(e){ e.preventDefault();
        try{
          if(mode==="signup"){ createAccount(u,p,false); }
          signIn(u,p);
          setUser(read(USERS_KEY)[u]);
        }catch(e){setErr(e.message);} }
      return(
        <div className="p-6 bg-white rounded-xl shadow max-w-md mx-auto mt-12">
          <h2 className="text-xl font-bold mb-3">{mode==="signin"?"Sign In":"Create Account"}</h2>
          <form onSubmit={submit} className="space-y-2">
            <input className="w-full p-3 border rounded" placeholder="username" value={u} onChange={e=>setU(e.target.value)} />
            <input className="w-full p-3 border rounded" placeholder="password" type="password" value={p} onChange={e=>setP(e.target.value)} />
            {err && <div className="text-red-600 text-sm">{err}</div>}
            <button className="w-full px-3 py-2 bg-slate-900 text-white rounded">{mode==="signin"?"Sign in":"Sign up"}</button>
          </form>
          <button onClick={()=>setMode(mode==="signin"?"signup":"signin")} className="w-full mt-3 px-3 py-2 border rounded">{mode==="signin"?"Need an account? Sign up":"Have an account? Sign in"}</button>
        </div>
      )
    }

    // ---- Dashboard ----
    function Dashboard({user,setUser,view,setView,timelines,handleCreateTimeline,handleAddPost,handleDeletePost,toggleLock,requestAddFamily,acceptRequest,declineRequest,messages,sendMessage}){
      return(
        <div className="p-4 max-w-6xl mx-auto">
          <h1 className="text-2xl font-bold mb-6">Moments</h1>
          <nav className="flex gap-2 mb-4">
            <button onClick={()=>setView("timelines")} className={`px-3 py-2 rounded ${view==="timelines"?"bg-slate-900 text-white":"border"}`}>Timelines</button>
            <button onClick={()=>setView("family")} className={`px-3 py-2 rounded ${view==="family"?"bg-slate-900 text-white":"border"}`}>Family</button>
            <button onClick={()=>setView("chat")} className={`px-3 py-2 rounded ${view==="chat"?"bg-slate-900 text-white":"border"}`}>Chat</button>
          </nav>
          {view==="timelines" && <Timelines user={user} timelines={timelines} handleCreateTimeline={handleCreateTimeline} handleAddPost={handleAddPost} handleDeletePost={handleDeletePost} toggleLock={toggleLock} />}
          {view==="family" && <Family user={user} requestAddFamily={requestAddFamily} acceptRequest={acceptRequest} declineRequest={declineRequest} />}
          {view==="chat" && <Chat user={user} messages={messages} sendMessage={sendMessage} />}
          <div className="mt-4">Hello, <b>{user.username}</b></div>
        </div>
      )
    }

    // ---- Timelines ----
    function Timelines({user,timelines,handleCreateTimeline,handleAddPost,handleDeletePost,toggleLock}){
      const [name,setName]=useState(""), [iconFile,setIconFile]=useState(null);
      const myT=Object.values(timelines).filter(t=>t.owner===user.username);
      return(
        <div>
          <div className="flex gap-2 mb-4">
            <input className="flex-1 p-2 border rounded" placeholder="New timeline name" value={name} onChange={e=>setName(e.target.value)} />
            <input type="file" accept="image/*" onChange={e=>setIconFile(e.target.files[0])} />
            <button onClick={()=>{if(name){handleCreateTimeline(name,iconFile);setName("");setIconFile(null);}}} className="px-3 py-2 bg-slate-900 text-white rounded">Create</button>
          </div>
          {myT.map(t=><Timeline key={t.id} timeline={t} isOwner handleAddPost={handleAddPost} handleDeletePost={handleDeletePost} toggleLock={toggleLock} />)}
        </div>
      )
    }

    function Timeline({timeline,isOwner,handleAddPost,handleDeletePost,toggleLock}){
      const [text,setText]=useState(""), [file,setFile]=useState(null), [open,setOpen]=useState(false);
      function handleUpload(){
        if(!file) return;
        const reader=new FileReader();
        reader.onload=()=>{ handleAddPost(timeline.id,{name:file.name,type:file.type,url:reader.result},"file"); setFile(null); };
        reader.readAsDataURL(file);
      }
      return(
        <div className="bg-white p-4 rounded-xl shadow mb-4">
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2 cursor-pointer" onClick={()=>setOpen(!open)}>
              {open ? (
                <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                </svg>
              ) : (
                <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              )}
              <h3 className="font-bold">{timeline.name}</h3>
            </div>
            {isOwner && <button onClick={()=>toggleLock(timeline.id)} className="px-3 py-1 border rounded text-sm">{timeline.locked?"üîí Private":"üîì Unlocked"}</button>}
          </div>
          {open && (
            <div className="mt-3 space-y-4">
              {isOwner && (
                <div className="space-y-2">
                  <textarea className="w-full border p-2 rounded" placeholder="Write something..." value={text} onChange={e=>setText(e.target.value)} />
                  <div className="flex gap-2">
                    <button onClick={()=>text && handleAddPost(timeline.id,text,"text")} className="px-3 py-1 bg-slate-900 text-white rounded">Add Text</button>
                    <input type="file" onChange={e=>setFile(e.target.files[0])} />
                    <button onClick={handleUpload} className="px-3 py-1 border rounded">Upload</button>
                  </div>
                </div>
              )}
              <div className="space-y-4 border-l-2 border-slate-200 pl-4">
                {timeline.posts.map(p=><PostCard key={p.id} p={p} isOwner={isOwner} timelineId={timeline.id} handleDeletePost={handleDeletePost}/>)}
              </div>
            </div>
          )}
        </div>
      )
    }

    function PostCard({p,isOwner,timelineId,handleDeletePost}){
      return(
        <div className="bg-slate-50 p-3 rounded shadow text-sm">
          <div className="flex justify-between text-xs text-slate-500 mb-1">
            <span>{p.owner} ‚Ä¢ {new Date(p.created).toLocaleString()}</span>
            {isOwner && <button onClick={()=>handleDeletePost(timelineId,p.id)} className="text-red-600">‚úï</button>}
          </div>
          {p.type==="text" && <div>{p.content}</div>}
          {p.type==="file" && (
            p.content.type.startsWith("image")
              ? <img src={p.content.url} className="w-full rounded"/>
              : <video src={p.content.url} controls className="w-full rounded"/>
          )}
        </div>
      )
    }

    // ---- Family ----
    function Family({user,requestAddFamily,acceptRequest,declineRequest}){
      const users=read(USERS_KEY);
      const pending=getPendingRequests(user.username);
      return(
        <div>
          <h2 className="text-xl font-semibold mb-3">Family</h2>
          <div className="mb-4">
            <h3 className="font-semibold mb-2">Requests</h3>
            {pending.length===0 && <div className="text-slate-500">No requests.</div>}
            {pending.map(from=>(
              <div key={from} className="flex justify-between items-center bg-slate-50 p-2 rounded mb-2">
                <span>{from}{users[from]?.isStar?" ‚≠ê":""}</span>
                <div className="flex gap-2">
                  <button onClick={()=>acceptRequest(from)} className="px-2 py-1 bg-green-500 text-white rounded">Accept</button>
                  <button onClick={()=>declineRequest(from)} className="px-2 py-1 bg-red-500 text-white rounded">Decline</button>
                </div>
              </div>
            ))}
          </div>
          <div>
            <h3 className="font-semibold mb-2">Add Family</h3>
            <AddFamilyForm onSubmit={requestAddFamily}/>
          </div>
        </div>
      )
    }

    function AddFamilyForm({onSubmit}){
      const [u,setU]=useState("");
      return(
        <form onSubmit={e=>{e.preventDefault(); if(u){onSubmit(u);setU("");}}} className="flex gap-2">
          <input className="flex-1 p-2 border rounded" placeholder="username" value={u} onChange={e=>setU(e.target.value)} />
          <button className="px-3 py-2 bg-slate-900 text-white rounded">Send</button>
        </form>
      )
    }

    // ---- Chat ----
    function Chat({user,messages,sendMessage}){
      const users=read(USERS_KEY);
      const myFriends=getFriends(user.username);
      const family=myFriends.filter(u=>u in users);
      const [selected,setSelected]=useState(family[0]||null);
      const [text,setText]=useState("");

      useEffect(()=>{ if(!selected && family[0]) setSelected(family[0]); },[family]);

      const conversation=(messages[user.username]?.[selected])||[];

      return(
        <div className="flex flex-col sm:flex-row gap-4">
          <aside className="w-full sm:w-48 bg-white rounded shadow p-2 max-h-[60vh] overflow-y-auto">
            <h4 className="font-semibold mb-2">Family Contacts</h4>
            {family.length===0 && <div className="text-slate-500">No family contacts.</div>}
            {family.map(o=>(
              <div key={o} className={`p-3 rounded cursor-pointer ${selected===o?"bg-slate-100":""}`} onClick={()=>setSelected(o)}>
                {o}{users[o]?.isStar?" ‚≠ê":""}
              </div>
            ))}
          </aside>
          <section className="flex-1 bg-white rounded shadow p-3 flex flex-col">
            {selected ? (
              <>
                <div className="flex-1 overflow-y-auto mb-2 max-h-[60vh]">
                  {conversation.map((m,i)=>(
                    <div key={i} className={`mb-2 ${m.from===selected?"text-left":"text-right"}`}>
                      <div className="inline-block px-3 py-1 rounded text-sm bg-slate-100">
                        {m.from}: {m.text}
                      </div>
                    </div>
                  ))}
                </div>
                <form onSubmit={e=>{e.preventDefault(); if(text){sendMessage(selected,text); setText("");}}} className="flex gap-2">
                  <input className="flex-1 border rounded p-3" placeholder="Message..." value={text} onChange={e=>setText(e.target.value)} />
                  <button className="px-4 py-2 bg-slate-900 text-white rounded">Send</button>
                </form>
              </>
            ): <div className="text-slate-500">No family selected</div>}
          </section>
        </div>
      )
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<MomentsApp/>);
  </script>
</body>
</html>

